%include "macros.asm"

BITS 32
                org     0x00010000

ehdr:                                           ; Elf32_Ehdr
                db      0x7F, "ELF", 1, 1, 1, 0 ; e_ident
        times 8 db      0
                dw      2                       ; e_type
                dw      3                       ; e_machine
                dd      1                       ; e_version
                dd      _start                  ; e_entry
                dd      phdr - $$               ; e_phoff
                dd      0                       ; e_shoff
                dd      0                       ; e_flags
                dw      ehdrsize                ; e_ehsize
                dw      phdrsize                ; e_phentsize
                dw      1                       ; e_phnum
                dw      0                       ; e_shentsize
                dw      0                       ; e_shnum
                dw      0                       ; e_shstrndx

ehdrsize        equ     $ - ehdr

phdr:                                           ; Elf32_Phdr
                dd      1                       ; p_type
                dd      0                       ; p_offset
                dd      $$                      ; p_vaddr
                dd      $$                      ; p_paddr
                dd      filesize                ; p_filesz
                dd      filesize                ; p_memsz
                dd      7                       ; p_flags
                dd      0x1000                  ; p_align

phdrsize        equ     $ - phdr

fname: times 49 db      '0'                     ; Apparently 49 is the filename length limit
                dw      0

programstart    equ     $

program:        mov     eax, 4                  ; 5 = sys_write
                mov     ebx, 1                  ; 1 = stdout
                push    'A'
                mov     ecx, esp                ; esp now points to your char
                mov     edx, 1                  ; edx should contain how many characters to print
                int     0x80                    ; sys_write(1, 'A', 1)
                add     esp, 4
                ret

programsize     equ     $ - programstart

do_inc_fname:   inc     byte [ebx]              ; Increment the filename
                ret

loop_inc_fname: cmp     byte [ebx], 57          ; Compare char to 9
                jne     do_inc_fname            ; If it's not 9, jump
                mov     byte [ebx], '0'         ; If it's 9, replace it with 0
                dec     ebx                     ; Increase the digit
                call    loop_inc_fname          ; Repeat
                ret

inc_fname:      mov     ebx, fname              ; Move the pointer to filename into ebx
                add     ebx, 48                 ; Move cursor into the last character of the filename
                call    loop_inc_fname          ; Increment the filename
                mov     ebx, fname              ; Fix ebx into beginning of filename
                ret

run:            mov     eax, 11                 ; 11 = sys_execve
                mov     ebx, fname              ; command
                mov     ecx, 0                  ; no arguments
                mov     edx, 0                  ; environment = NULL
                int     0x80                    ; sys_execve(fname, fname, NULL)
                ret

fork:           mov     eax, 2                  ; 2 = sys_fork
                int     0x80                    ; sys_fork()

                cmp     eax, 0                  ; if eax is zero we are in the in fork
                jz      run                     ; jump to run if eax is zero
                ret

rand_byte:      mov     ebx, program            ; Move the cursor to the beginning of the program
                randomNumber    0, programsize  ; generate random number between 0 and "programsize"
                add     ebx, eax                ; go N instructions forward (N = random offset in the eax register)
                rdtsc                           ; generate random bytes using CPU's clock (Read Time-Stamp Counter)
                mov     byte [ebx], al          ; replace the byte with a randomly generated byte
                ret

left_shift:     mov     ebx, eax                ; Copy delete offset to ebx
                inc     ebx                     ; increment ebx
                mov     ecx, [ebx]              ; move the byte pointed by ebx into ecx (left shift - first half)
                mov     [eax], ecx              ; move the byte pointed by ecx into eax (left shift - second half)
                inc     eax                     ; go one byte forward
                cmp     eax, filesize           ; compare eax to filesize
                jng     left_shift              ; if eax not greater than the filsize then repeat
                ret

shrink_loop:    randomNumber 1, esi             ; Delete offset, between 1 and "current programsize"
                add     eax, programstart       ; Add programstart offset to delete offset to find the true location
                call    left_shift              ; left shift the whole program starting from the delete offset
                dec     esi                     ; decrement the programsize
                dec     edi                     ; decrement the filesize
                pop     eax                     ; pop the shrink size into eax
                dec     eax                     ; decrement the shrink size
                cmp     eax, 0                  ; compare the shrink size with 0
                push    eax                     ; push the shrink size into the stack
                jnz     shrink_loop             ; If the shrink size is not 0 then repeat
                ret

shrink:         randomNumber 1, programsize     ; Shrink size, between 1 and "programsize"
                push    eax                     ; push the shrink size into the stack
                mov     esi, programsize        ; move programsize into esi (only decrement this)
                mov     edi, filesize           ; move filesize into edi (only decrement this)
                call    shrink_loop             ; call the shrink_loop subroutine
                pop     eax                     ; clear the stack
                ret

mutate:         randomNumber    0, 99           ; Generate random number between 0 and 99
                cmp     eax, 80                 ; compare eax (random number) with 80
                jl      rand_byte               ; %80 : change a random byte without growing or shrinking the program
                cmp     eax, 85                 ; compare eax (random number) with 85
                jl      shrink                  ;  %5 : shrink the program randomly
                ret

evolve:         randomNumber    0, 1            ; Generate random number between 0 and 1
                cmp     eax, 1                  ; if generated random number is 1 mutate
                jz      mutate                  ; jump to mutate if eax is zero
                ret

replicate:      call    evolve
                mov     eax, 5                  ; 5 = sys_open
                call    inc_fname               ; Increment the filename
                mov     ecx, 65                 ; 65 = O_WRONLY | O_CREAT
                mov     edx, 777q               ; File mode (octal)
                int     0x80                    ; sys_open(fname, 65, 777)
                lea     edx, [filesize]         ; Load effective address of filesize
                xchg    eax, ebx                ; Move the file descriptor in eax to ebx
                xchg    eax, ecx                ; Swap eax and ecx
                mov     cl, 0                   ; Point out to the beginning of the program by removing first 8 bits
                mov     al, 4                   ; 4 = sys_write
                int     0x80                    ; sys_write(file_descriptor, *content, filesize)
                mov     eax, 6                  ; 6 = sys_close
                int     0x80                    ; sys_close(file_descriptor)
                ; call    fork
                call    run
                ret

exit:           mov     bl, 0                   ; 0 = Exit code
                mov     al, 1                   ; 1 = sys_exit
                int     0x80                    ; sys_exit(0)

_start:         call    program
                call    replicate
                call    replicate
                call    exit

filesize        equ     $ - $$
